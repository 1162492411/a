<search><entry><title>Docker 常用命令</title><url>https://www.zyg-tech.me/post/docker-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url><categories><category>Docker</category></categories><tags><tag>容器化</tag><tag>部署运维</tag><tag>Docker</tag><tag>命令</tag></tags><content type="html"> Docker是一个开源的应用容器引擎，让开发者可以打包应用及依赖包到一个可移植的镜像中，然后发布到任何流行的Linux或Windows机器上。使用Docker可以更方便地打包、测试以及部署应用程序。
Docker环境安装 安装yum-utils； yum install -y yum-utils device-mapper-persistent-data lvm2 复制代码 为yum源添加docker仓库位置； yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo 复制代码 安装docker服务； yum install docker-ce 复制代码 启动docker服务。 systemctl start docker 复制代码 Docker镜像常用命令 搜索镜像 docker search java 复制代码 下载镜像 docker pull java:8 复制代码 查看镜像版本 由于docker search命令只能查找出是否有该镜像，不能找到该镜像支持的版本，所以我们需要通过Docker Hub来搜索支持的版本。
进入Docker Hub的官网，地址：https://hub.docker.com
然后搜索需要的镜像：
查看镜像支持的版本：
进行镜像的下载操作：
docker pull nginx:1.17.0 列出镜像 docker images 删除镜像 指定名称删除镜像： docker rmi java:8 指定名称删除镜像（强制）： docker rmi -f java:8 删除所有没有引用的镜像： docker rmi `docker images | grep none | awk &amp;#39;{print $3}&amp;#39;` 强制删除所有镜像： docker rmi -f $(docker images) 打包镜像 # -t 表示指定镜像仓库名称/镜像名称:镜像标签 .表示使用当前目录下的Dockerfile文件 docker build -t mall/mall-admin:1.0-SNAPSHOT . Docker容器常用命令 新建并启动容器 docker run -p 80:80 --name nginx \ -e TZ=&amp;#34;Asia/Shanghai&amp;#34; \ -v /mydata/nginx/html:/usr/share/nginx/html \ -d nginx:1.17.0 -p：将宿主机和容器端口进行映射，格式为：宿主机端口:容器端口； &amp;ndash;name：指定容器名称，之后可以通过容器名称来操作容器； -e：设置容器的环境变量，这里设置的是时区； -v：将宿主机上的文件挂载到宿主机上，格式为：宿主机文件目录:容器文件目录； -d：表示容器以后台方式运行。 列出容器 列出运行中的容器： docker ps 列出所有容器： docker ps -a 停止容器 注意：$ContainerName表示容器名称，$ContainerId表示容器ID，可以使用容器名称的命令，基本也支持使用容器ID，比如下面的停止容器命令。
docker stop $ContainerName(or $ContainerId) 例如：
docker stop nginx #或者 docker stop c5f5d5125587 强制停止容器 docker kill $ContainerName 启动容器 docker start $ContainerName 进入容器 先查询出容器的pid： docker inspect --format &amp;#34;{{.State.Pid}}&amp;#34; $ContainerName 根据容器的pid进入容器： nsenter --target &amp;#34;$pid&amp;#34; --mount --uts --ipc --net --pid 删除容器 删除指定容器： docker rm $ContainerName 按名称通配符删除容器，比如删除以名称mall-开头的容器： docker rm `docker ps -a | grep mall-* | awk &amp;#39;{print $1}&amp;#39;` 强制删除所有容器； docker rm -f $(docker ps -a -q) 查看容器的日志 查看容器产生的全部日志： docker logs $ContainerName 动态查看容器产生的日志： docker logs -f $ContainerName 查看容器的IP地址 docker inspect --format &amp;#39;{{ .NetworkSettings.IPAddress }}&amp;#39; $ContainerName 修改容器的启动方式 # 将容器启动方式改为always docker container update --restart=always $ContainerName 同步宿主机时间到容器 docker cp /etc/localtime $ContainerName:/etc/ 指定容器时区 docker run -p 80:80 --name nginx \ -e TZ=&amp;#34;Asia/Shanghai&amp;#34; \ -d nginx:1.17.0 查看容器资源占用状况 查看指定容器资源占用状况，比如cpu、内存、网络、io状态： docker stats $ContainerName 查看所有容器资源占用情况： docker stats -a 查看容器磁盘使用情况 docker system df 执行容器内部命令 docker exec -it $ContainerName /bin/bash 指定账号进入容器内部 # 使用root账号进入容器内部 docker exec -it --user root $ContainerName /bin/bash 查看所有网络 docker network ls ## 结果示例 [root@local-linux ~]# docker network ls NETWORK ID NAME DRIVER SCOPE 59b309a5c12f bridge bridge local ef34fe69992b host host local a65be030c632 none 创建外部网络 docker network create -d bridge my-bridge-network 指定容器网络 docker run -p 80:80 --name nginx \ --network my-bridge-network \ -d nginx:1.17.0 修改镜像的存放位置 查看Docker镜像的存放位置： docker info | grep &amp;#34;Docker Root Dir&amp;#34; 关闭Docker服务： systemctl stop docker 先将原镜像目录移动到目标目录： mv /var/lib/docker /mydata/docker 建立软连接： ln -s /mydata/docker /var/lib/docker 再次查看可以发现镜像存放位置已经更改。 本文 GitHub github.com/macrozheng/… 已经收录，欢迎大家Star！
作者：MacroZheng 链接：https://juejin.cn/post/6895888125886332941 来源：掘金 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</content></entry><entry><title>Netty架构简介</title><url>https://www.zyg-tech.me/post/netty%E6%9E%B6%E6%9E%84%E7%AE%80%E4%BB%8B/</url><categories><category>Netty</category></categories><tags><tag>高性能组件</tag><tag>代码研究</tag></tags><content type="html"> Netty功能特性如下
1）传输服务：支持 BIO 和 NIO；
2）容器集成：支持 OSGI、JBossMC、Spring、Guice 容器；
3）协议支持：HTTP、Protobuf、二进制、文本、WebSocket 等一系列常见协议都支持。还支持通过实行编码解码逻辑来实现自定义协议；
4）Core 核心：可扩展事件模型、通用通信 API、支持零拷贝的 ByteBuf 缓冲对象。
高性能设计 Netty 作为异步事件驱动的网络，高性能之处主要来自于其 I/O 模型和线程处理模型，前者决定如何收发数据，后者决定如何处理数据
Netty采用的I/O模型为NIO,如下图
Netty采用的线程处理模型为Reactor模型.Reactor 模型中有 2 个关键组成：
1）Reactor：Reactor 在一个单独的线程中运行，负责监听和分发事件，分发给适当的处理程序来对 IO 事件做出反应。它就像公司的电话接线员，它接听来自客户的电话并将线路转移到适当的联系人；
2）Handlers：处理程序执行 I/O 事件要完成的实际事件，类似于客户想要与之交谈的公司中的实际官员。Reactor 通过调度适当的处理程序来响应 I/O 事件，处理程序执行非阻塞操作。
Reactor模型共有3个变种:单 Reactor 单线程、单 Reactor 多线程、主从 Reactor 多线程.
Netty的线程模型是基于主从 Reactors 多线程模型进行修改.
核心组件 Boostrap:客户端程序的启动引导类,主要作用是配置整个 Netty 程序，串联各个组件
ServerBootstrap:服务端启动引导类
ChannelEvent : 因为Netty是基于事件驱动的，ChannelEvent就相当于某一个事件，比如说连接成功时打印一句话
Channel:网络通信的组件，能够用于执行网络 I/O 操作,下面是一些常用的 Channel 类型：
NioSocketChannel，异步的客户端 TCP Socket 连接。 NioServerSocketChannel，异步的服务器端 TCP Socket 连接。 NioDatagramChannel，异步的 UDP 连接。 NioSctpChannel，异步的客户端 Sctp 连接。 NioSctpServerChannel，异步的 Sctp 服务器端连接，这些通道涵盖了 UDP 和 TCP 网络 IO 以及文件 IO。
Selector:通过 Selector 一个线程可以监听多个连接的 Channel 事件。当向一个 Selector 中注册 Channel 后，Selector 内部的机制就可以自动不断地查询Selector中注册的 Channel 是否有已就绪的 I/O 事件（例如可读，可写，网络连接完成等），这样程序就可以很简单地使用一个线程高效地管理多个 Channel
NioEventLoop:NioEventLoop 中维护了一个线程和任务队列，支持异步提交执行任务，线程启动时会调用 NioEventLoop 的 run 方法，执行 I/O 任务和非 I/O 任务
NioEventLoopGroup : 主要管理 eventLoop 的生命周期，可以理解为一个线程池，内部维护了一组线程，每个线程(NioEventLoop)负责处理多个 Channel 上的事件
ChannelHandler : 一个接口，处理 I/O 事件或拦截 I/O 操作，并将其转发到其 ChannelPipeline(业务处理链)中的下一个处理程序。
ChannelHandler 本身并没有提供很多方法，因为这个接口有许多的方法需要实现，方便使用期间，可以继承它的子类：
ChannelInboundHandler 用于处理入站 I/O 事件。 ChannelOutboundHandler 用于处理出站 I/O 操作。
或者使用以下适配器类：
ChannelInboundHandlerAdapter 用于处理入站 I/O 事件。 ChannelOutboundHandlerAdapter 用于处理出站 I/O 操作。 ChannelDuplexHandler 用于处理入站和出站事件。
ChannelPipline : 保存 ChannelHandler 的 List，用于处理或拦截 Channel 的入站事件和出站操作,可以理解为一种高级形式的拦截过滤器模式
ChannelHandlerContext : 保存 Channel 相关的所有上下文信息
组件间关系 当客户端和服务端连接的时候会建立一个 Channel,这个 Channel 我们可以理解为 Socket 连接，它负责基本的 IO 操作，例如：bind（），connect（），read（），write（） 等等,简单的说，Channel 就是代表连接，实体之间的连接，程序之间的连接，文件之间的连接，设备之间的连接。同时它也是数据入站和出站的载体。
EventLoopGroup、EventLoop、Channel关系如下
在 Netty 中每个 Channel 都有且仅有一个 ChannelPipeline 与之对应，它们的组成关系如下：
一个 Channel 包含了一个 ChannelPipeline，而 ChannelPipeline 中又维护了一个由 ChannelHandlerContext 组成的双向链表，并且每个 ChannelHandlerContext 中又关联着一个 ChannelHandler。
入站事件和出站事件在一个双向链表中，入站事件会从链表 head 往后传递到最后一个入站的 handler，出站事件会从链表 tail 往前传递到最前一个出站的 handler，两种类型的 handler 互不干扰。
这些核心组件的整体关系如下
核心工作流程 典型的初始化并启动 Netty 服务端的过程代码如下：
public final class EchoServer { static final boolean SSL = System.getProperty(&amp;#34;ssl&amp;#34;) != null; static final int PORT = Integer.parseInt(System.getProperty(&amp;#34;port&amp;#34;, &amp;#34;8007&amp;#34;)); public static void main(String[] args) throws Exception { // 配置SSL final SslContext sslCtx; if (SSL) { SelfSignedCertificate ssc = new SelfSignedCertificate(); sslCtx = SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey()).build(); } else { sslCtx = null; } // 配置服务端 EventLoopGroup bossGroup = new NioEventLoopGroup(1); EventLoopGroup workerGroup = new NioEventLoopGroup(); final EchoServerHandler serverHandler = new EchoServerHandler(); try { ServerBootstrap b = new ServerBootstrap(); b.group(bossGroup, workerGroup) .channel(NioServerSocketChannel.class) .option(ChannelOption.SO_BACKLOG, 100) .handler(new LoggingHandler(LogLevel.INFO)) .childHandler(new ChannelInitializer&amp;lt;SocketChannel&amp;gt;() { @Override public void initChannel(SocketChannel ch) throws Exception { ChannelPipeline p = ch.pipeline(); if (sslCtx != null) { p.addLast(sslCtx.newHandler(ch.alloc())); } //p.addLast(new LoggingHandler(LogLevel.INFO)); p.addLast(serverHandler); } }); // Start the server. ChannelFuture f = b.bind(PORT).sync(); // Wait until the server socket is closed. f.channel().closeFuture().sync(); } finally { // Shut down all event loops to terminate all threads. bossGroup.shutdownGracefully(); workerGroup.shutdownGracefully(); } } } 基本过程描述如下：
1）初始化创建 2 个 NioEventLoopGroup：其中 boosGroup 用于 Accetpt 连接建立事件并分发请求，workerGroup 用于处理 I/O 读写事件和业务逻辑。
2）基于 ServerBootstrap(服务端启动引导类)：配置 EventLoopGroup、Channel 类型，连接参数、配置入站、出站事件 handler。
3）绑定端口：开始工作。
Netty启动流程图如下
结合上面介绍的 Netty Reactor 模型，介绍服务端 Netty 的工作架构图：
ps:上图中NioEventGroup有误,应为NioEventLoop</content></entry><entry><title>MySQL全文索引使用</title><url>https://www.zyg-tech.me/post/mysql%E5%85%A8%E6%96%87%E7%B4%A2%E5%BC%95/</url><categories><category>MySQL</category></categories><tags><tag>MySQL</tag><tag>数据库</tag><tag>全文索引</tag></tags><content type="html"> 1.简介 在Web应用中,经常会遇到按照关键字进行模糊搜索的需求,当参数搜索的数据量较少时,我们一般使用like进行搜索,但是当数据量达到一定程度后,like方式的速度就会很慢很慢,这时候我们可以借助一些全文搜索的组件来实现需求.MySQL就提供了全文索引来支持模糊搜索.
2.限制条件 2.1引擎限制 MySQL 5.6 以前的版本，只有 MyISAM 存储引擎支持全文索引；
MySQL 5.6 及以后的版本，MyISAM 和 InnoDB 存储引擎均支持全文索引
2.2版本号限制 Mysql自v5.6.24版本开始在InnoDB引擎中增加全文索引功能，支持对英文的全文搜索,默认以空格作为分隔符;自v5.7版本开始增加ngram分词器以支持中文
2.3字段类型限制 全文索引支持的字段类型为char、varchar、text等这些基于文本的列
2.4连表限制 全文搜索仅支持在同一张表中进行,不支持对多张表中的关键字进行全文搜索
3.准备索引 我们以report表为例
-- 准备表 create table report ( id int auto_increment primary key, content varchar(1000) null ); -- 在content字段创建普通的全文索引 create fulltext index content_fti on report(content); -- 在content字段创建支持中文的全文索引 create fulltext index content_fti on report(content) WITH PARSER ngram; -- 删除索引,方式一 drop index content_fti on report; -- 删除索引,方式二 alter table report drop index content_fti; 4.准备配置 ​ 使用全文索引搜索时,搜索引擎受全文搜索的单词长度影响,如果关键词长度小于该配置项,那么将无法搜索出相匹配的结果,通过命令可以查看出相关配置项
-- 查看全文搜索配置 show variables like &amp;#39;%ft%&amp;#39;; -- 命令执行结果 // MyISAM:关键词最小长度默认4字符,最大长度84字符 ft_min_word_len = 4; ft_max_word_len = 84; // InnoDB:关键词最小长度默认3字符,最大长度84字符 innodb_ft_min_token_size = 3; innodb_ft_max_token_size = 84; 我们以常用的Innodb引擎为例,在MySQL的配置文件中修改配置项
[mysqld] innodb_ft_min_token_size = 1 ft_min_word_len = 1 修改后需要重启MySQL,然后修复全文索引(可以删除索引然后重新建立索引,如果是MyIsam引擎,也可以执行repair命令修复)
然而对于使用了ngram的全文索引来讲,它的全文搜索单词长度配置会忽略上述四个配置项,真正生效的为配置项ngram_token_size(默认2),可以通过在MySQL的配置文件中修改以下配置项或启动时追加参数&amp;ndash;ngram_token_size=1来实现对该配置项的修改
[mysqld] ngram_token_size=1 同样的,修改此项后需要重建全文索引
5.准备数据 略
6.使用索引 与like不同,全文索引的搜索需要使用match agnist,示例如下
select * from report where match(content) against(&amp;#39;测试关键词&amp;#39;); match agnist本身还会返回非负浮点数作为搜索的结果行与关键词的相关度.除了match agnist的基础使用,全文搜索还支持以不同的检索模式进行搜索,常用的全文检索模式有两种： 1、自然语言模式(NATURAL LANGUAGE MODE) ， 自然语言模式是MySQL 默认的全文检索模式。自然语言模式不能使用操作符，不能指定关键词必须出现或者必须不能出现等复杂查询。当sql中指定了IN NATURAL LANGUAGE MODE修饰符或未给出修饰符，则全文搜索是自然语言搜索模式 。 2、BOOLEAN模式(BOOLEAN MODE) BOOLEAN模式可以使用操作符，可以支持指定关键词必须出现或者必须不能出现或者关键词的权重高还是低等复杂查询。
6.1自然语言检索模式 ​ 在该模式下,可以指定IN NATURAL LANGUAGE MOD,也可以不指定修饰符,下面给出一个按照结果行相关度倒序排列的SQL示例
select *,match(content) against(&amp;#39;一切&amp;#39;) as score from report where match(content) against(&amp;#39;一切&amp;#39;) order by score desc; 6.2布尔检索模式 MySQL可以使用IN BOOLEAN MODE修饰符执行布尔型全文本搜索 。在这种模式下,支持通过一些正则来进行高级搜索,布尔模式下支持以下操作符：
“+”表示必须包含 “-”表示必须排除 “&amp;gt;”表示出现该单词时增加相关性 “&amp;lt;”表示出现该单词时降低相关性 “*”表示通配符 “~”允许出现该单词，但是出现时相关性为负 “&amp;quot;&amp;quot;”表示短语 下面给出一些示例 &amp;#39;apple banana&amp;#39; ## 无操作符，表示或，要么包含apple，要么包含banana &amp;#39;+apple +juice&amp;#39; ## 必须同时包含两个词apple和juice &amp;#39;+apple macintosh&amp;#39; ## 必须包含apple，但是如果也包含macintosh的话，相关性会更高。 &amp;#39;+apple -macintosh&amp;#39; ## 必须包含apple，同时不能包含macintosh。 &amp;#39;+apple ~macintosh&amp;#39; ## 必须包含apple，但是如果也包含macintosh的话，相关性要比不包含macintosh的记录低。 &amp;#39;+apple +(&amp;gt;juice &amp;lt;pie)&amp;#39; ## 查询必须包含apple和juice或者apple和pie的记录，但是apple juice的相关性要比apple pie高。 &amp;#39;apple*&amp;#39; ## 查询包含以apple开头的单词的记录，如apple、apples、applet。 &amp;#39;&amp;#34;some words&amp;#34;&amp;#39; ## 使用双引号把要搜素的词括起来，效果类似于like &amp;#39;%some words%&amp;#39;， 例如“some words of wisdom”会被匹配到，而“some noise words”就不会被匹配。 7.InnoDB引擎的相关性 InnoDB引擎的全文索引基于Sphinx,算法基于BM-25和TF-IDF,InnoDB使用“术语频率-逆文档频率” （TF-IDF）加权系统的变体对给定的全文搜索查询对文档的相关性进行排名,单词出现在文档中的频率越高，单词出现在文档集合中的频率越低，文档的排名就越高。
7.1相关性排名的计算方式 术语频率（TF）值是单词在文档中出现的次数。IDF单词的逆文档频率（）值是使用以下公式计算的，其中 total_records是集合中matching_records的记录数，并且是搜索词出现的记录数。
${IDF} = log10( ${total_records} / ${matching_records} ) 当文档多次包含一个单词时，IDF值将乘以TF值：
${TF} * ${IDF} 使用TF和IDF 值，使用以下公式计算文档的相关性等级：
${rank} = ${TF} * ${IDF} * ${IDF} 8.停止词 可以通过配置停止词来禁止某些词语参与全文索引,详细使用见全文停用词
9.InnoDB分词原理 InnoDB 全文索引具有倒排索引设计。倒排索引存储一个单词列表，对于每个单词，存储单词出现的文档列表。为了支持邻近搜索，每个单词的位置信息也作为字节偏移量存储。
创建全文索引时,MySQL将创建一组表用于辅助
## 查看索引表 SELECT table_id, name, space from INFORMATION_SCHEMA.INNODB_SYS_TABLES WHERE name LIKE &amp;#39;test/%&amp;#39;; ## 命令执行结果 424 test/FTS_000000000000006b_0000000000000388_INDEX_1 423 425 test/FTS_000000000000006b_0000000000000388_INDEX_2 424 426 test/FTS_000000000000006b_0000000000000388_INDEX_3 425 427 test/FTS_000000000000006b_0000000000000388_INDEX_4 426 428 test/FTS_000000000000006b_0000000000000388_INDEX_5 427 429 test/FTS_000000000000006b_0000000000000388_INDEX_6 428 430 test/FTS_000000000000006b_BEING_DELETED 429 431 test/FTS_000000000000006b_BEING_DELETED_CACHE 430 432 test/FTS_000000000000006b_CONFIG 431 433 test/FTS_000000000000006b_DELETED 432 434 test/FTS_000000000000006b_DELETED_CACHE 433 107 test/report 93 前六个表代表反向索引，并称为辅助索引表。对传入文档进行标记时，各个单词（也称为 “标记”）与位置信息和关联的文档ID（DOC_ID）一起插入索引表中。根据单词第一个字符的字符集排序权重，单词在六个索引表中得到完全排序和分区。
倒排索引分为六个辅助索引表，以支持并行索引创建。默认情况下，两个线程对索引表中的单词和相关数据进行标记化，排序和插入。线程数可以使用该innodb_ft_sort_pll_degree 选项配置 。FULLTEXT在大型表上创建索引时，请考虑增加线程数 。
辅助索引表名称以前缀 FTS_和后缀 INDEX_*。每个索引表通过索引表名称中与table_id索引表的匹配的十六进制值与索引表相关联。例如，table_id所述的 test/opening_lines表是 327，为此，十六进制值是0x147。如前面的示例所示，十六进制值“ 147 ”出现在与该test/opening_lines表关联的索引表的名称中。</content></entry><entry><title>Docker MySQL部署</title><url>https://www.zyg-tech.me/post/docker-mysql%E9%83%A8%E7%BD%B2/</url><categories><category>MySQL</category></categories><tags><tag>MySQL</tag><tag>Docker</tag></tags><content type="html"> 前提 安装docker,mac环境下可直接安装docker Desktop
拉取 #拉取5.7版本的mysql镜像 docker push mysql:5.7
运行 docker run -p 13306:3306 \ --name d-mysql-57 \ -e MYSQL_ROOT_PASSWORD=Mo20100528 \ -v /Users/zyg/softs/docker/mysql57/data:/var/lib/mysql \ -v /Users/zyg/softs/docker/mysql57/logs:/var/log/mysql \ -v /Users/zyg/softs/docker/mysql57/conf/my.cnf:/etc/my.cnf \ -d mysql:5.7 参数说明:
run　run 是运行一个容器 -d　表示后台运行 -p　表示容器内部端口和服务器端口映射关联 &amp;ndash;privileged=true　设值MySQL 的root用户权限, 否则外部不能使用root用户登陆 -v 容器内的路径(如/etc/mysql)挂载到宿主机 -e MYSQL_ROOT_PASSWORD=xxx 设置MySQL数据库root用户的密码 &amp;ndash;name 设值容器名称为mysql mysql:5.7 表示从docker镜像mysql:5.7中启动一个容器 &amp;ndash;character-set-server=utf8mb4 &amp;ndash;collation-server=utf8mb4_general_ci 设值数据库默认编码 停止上面启动的容器,容器名字为&amp;quot;d-mysql-57&amp;rdquo;
docker stop d-mysql-57 配置账户 ##进入容器
docker exec -it d-mysql-57 bash ##登录MySQL
``mysql -uroot -p` ##创建用户,名叫test,密码是test123,开启远程访问权限
GRANT ALL PRIVILEGES ON *.* TO &amp;#39;test&amp;#39;@&amp;#39;%&amp;#39; IDENTIFIED BY &amp;#39;test123&amp;#39; WITH GRANT OPTION; ##创建数据库,名叫xxx
create database xxx; 之后便可以通过该用户执行业务脚本</content></entry></search>