---
title: "微服务常见面试题"
date: 2021-03-21T15:09:09+08:00
draft: false
categories:
  - 面试题
  - Java
  - 微服务
  - 分布式
tags:
  - 面试题
  - Java
  - 微服务
  - 分布式
---

{{< spoiler >}} 



{{< / spoiler >}}

# 理论篇

## 什么是CAP定理

{{< spoiler >}} 

* C ：一致性，在分布式系统中数据往往存在多个副本，一致性描述的是这些副本中的数据在内容和组织上的一致
* A ：可用性，在用户能够容忍的时间范围内返回用户期望的结果
* P ：分区容错性，在出现网络分区时系统仍然能够对外提供一致性的可用服务

{{< / spoiler >}}

## 什么是BASE理论

{{< spoiler >}} 

它是对CAP理论的进一步延伸

* BA ：基本可用，分布式系统在出现不可预知故障的时候，允许损失部分可用性
* S ： 软状态，许系统中的数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时
* E ：最终一致性，系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态

{{< / spoiler >}}

## BASE理论和CAP定理的关系

{{< spoiler >}} 

在CAP定理中，如果满足其中两项(CP/AP)，在此基础上设计的系统就是BASE架构

{{< / spoiler >}}



# 分布式一致性

## 分布式一致性的定义

{{< spoiler >}} 

**一致性是指**分布式系统中的多个服务节点，给定一系列的操作，在约定协议的保障下，使它们**对外界呈现的状态是一致的。**换句话说**，也就是**保证集群中所有服务节点中的**数据完全相同**并且能够**对某个提案（Proposal）达成一致**

{{< / spoiler >}}

## 分布式一致性的要求

{{< spoiler >}} 

* 有限性 ： 达成一致的结果在**有限的时间**内完成
* 约同性 ：不同节点最终完成决略的结果是相同
* 合法性 ：决策的结果必须是系统中某个节点提出来的

{{< / spoiler >}}

## 分布式一致性的分类

{{< spoiler >}} 

* **严格一致性** ：对于数据项x的任何读操作将返回最近一次对x进行的写操作的结果所对应的值，效果上等同于一台机器
* **强一致性** ： 包括**顺序一致性**和**线性一致性**，**顺序一致性**是指任何执行结果都是相同的，就好像所有进程对数据存储的读、写操作是按某种序列顺序执行的，并且每个进程的操作按照程序所指定的顺序出现在这个序列中；**线性一致性**假设操作具有一个**全局有效时钟的时间戳**，但是这个时钟仅具有有限的精确度。要求时间戳在前的进程先执行
* **弱一致性** ：指系统并不保证后续进程或线程的访问都会返回最新的更新的值，系统在数据成功吸入之后，不承诺立即可以读到最新写入的值，也不会具体承诺多久读到。但是会尽可能保证在某个时间级别（秒级）之后。可以让数据达到一致性状态
* **最终一致性** ：**最终一致性**是弱一致性的特定形式。系统保证在没有后续更新的前提下，系统最终返回上一次更新操作的值。 **也就是说**，如果经过一段时间后要求能访问到更新后的数据，则是最终一致性

{{< / spoiler >}}

# 分布式共识性

##  分布式共识性的定义

{{< spoiler >}} 

**共识性**描述了分布式系统中多个节点之间，彼此对某个状态达成一致结果的过程。 在实践中，要保障系统满足不同程度的一致性，核心过程往往需要通过共识算法来达成

{{< / spoiler >}}

## 分布式共识性的常见算法

{{< spoiler >}} 

* Paxos
* Raft
* Proof-of-Work
* Proof-of-Stake
* Delegated Proof-of-Stake

{{< / spoiler >}}

## 共识性和一致性的区别

{{< spoiler >}} 

**一致性描述的是结果状态**，**共识则是一种手段**。**达成某种共识并不意味着就保障了一致性（这里的一致性指强一致性）。只能说共识机制，能够实现某种程度上的一致**

{{< / spoiler >}}



# 分布式协调

## Zookeeper的使用场景

{{< spoiler >}} 

* 命名服务 ： 提供全局一致性的id
* 配置管理 ： 将其作为一个高可用的配置存储器，允许分布式应用的参与者检索和更新配置文件
* 分布式锁 ： 通过 ZooKeeper 的临时节点和 Watcher 机制来实现分布式锁
* 集群管理 ： 
  * 通过创建临时节点来建立心跳检测机制
  * 分布式系统的每个服务节点还可以将自己的节点状态写入临时节点从而完成节点的状态报告
  * 通过数据的订阅和发布功能，ZooKeeper 还能对分布式系统进行模块的解耦和任务的调度
  * 通过监听机制，还能对分布式系统的服务节点进行动态上下线，从而实现服务的动态扩容
* Leader节点选举
* 队列管理 ： 实现同步队列/生产者和消费者模型

{{< / spoiler >}}

## 概述Zookeeper的选举流程

{{< spoiler >}} 

* **自增选举轮次**
* **初始化选票**
* **发送初始化选票**
* **接收外部投票**
* **判断选举轮次**
* **选票 PK**
* **统计选票**
* **更新服务器状态**

{{< / spoiler >}}

## 概述Zookeeper的ZAB协议的原子广播

{{< spoiler >}} 

**所有的写请求都会被转发给 Leader，Leader 会以原子广播的方式通知 Follow。当半数以上的 Follow 已经更新状态持久化后，Leader 才会提交这个更新，然后客户端才会收到一个更新成功的响应。**这有些类似数据库中的两阶段提交协议。

在整个消息的广播过程中，Leader 服务器会每个事务请求生成对应的 Proposal，并为其分配一个全局唯一的递增的事务 ID(ZXID)，之后再对其进行广播。

{{< / spoiler >}}

# 分布式事务

## 常见的分布式事务协议有哪些

{{< spoiler >}} 

两阶段提交、三阶段提交

{{< / spoiler >}}

## 概述两阶段提交的流程

![img](https://gitee.com/1162492411/pic/raw/master/分布式-事务-两阶段提交流程.png)

{{< spoiler >}} 

一阶段 ：投票

二阶段 ：提交

{{< / spoiler >}}

## 两阶段提交有哪些缺点

{{< spoiler >}} 

* 同步阻塞 ： 执行过程中，所有参与节点都是事务阻塞型的。当参与者占有公共资源时，其他第三方节点访问公共资源不得不处于阻塞状态
* 协调者故障 ：由于协调者的重要性，一旦协调者发生故障，参与者会一直阻塞下去
* 参与者故障导致的数据不一致 ： 在二阶段提交的阶段二中，当协调者向参与者发送commit请求之后，发生了局部网络异常或者在发送commit请求过程中协调者发生了故障，这回导致只有一部分参与者接受到了commit请求。而在这部分参与者接到commit请求之后就会执行commit操作。但是其他部分未接到commit请求的机器则无法执行事务提交。于是整个分布式系统便出现了数据不一致性的现象
* 协调者与参与者故障导致的事务状态不确定 ：协调者再发出commit消息之后宕机，而唯一接收到这条消息的参与者同时也宕机了。那么即使协调者通过选举协议产生了新的协调者，这条事务的状态也是不确定的，没人知道事务是否被已经提交

{{< / spoiler >}}

## 概述三阶段提交的流程

{{< spoiler >}} 

与两阶段提交不同的是，三阶段提交有两个改动点。

1、引入超时机制。同时在协调者和参与者中都引入超时机制。
2、在第一阶段和第二阶段中插入一个准备阶段。保证了在最后提交阶段之前各参与节点的状态是一致的。

共分为三个阶段 ：canCommit、preCommit、doCommit

{{< / spoiler >}}

![WX20210322-155240@2x](https://gitee.com/1162492411/pic/raw/master/分布式-事务-三阶段提交流程.png)

## 常见的分布式事务解决方案有哪些

{{< spoiler >}} 

* 全局事务XA协议
  * 需要三种角色：AP(业务系统)、TM(事务管理器)、RM(资源管理器),这只是一种规范，具体的实现包括两阶段提交、三阶段提交等，例如MySQL支持外部的XA接口以及MySQL支持内部的两阶段提交(bin log 与redo log)
* 基于消息的分布式事务
  * 假定存在业务系统A、业务系统B、消息中间件。系统A成功处理后通过消息中间件发出消息，系统B接收消息并处理
* 最大努力通知事务
  * 在基于消息的分布式事务基础上，定时处理发送失败的消息 + 定时校对系统AB
* TCC两阶段补偿事务
  * 分为三个部分 ：Try(检查待执行的业务方，预留资源)、Confirm(执行业务)、Cancel(若前阶段执行失败则回滚)  (模仿数据库本地事务，将其逻辑从数据库层迁移到服务层)

{{< / spoiler >}}