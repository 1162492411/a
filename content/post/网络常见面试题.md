---
title: "网络常见面试题"
date: 2021-03-13T17:33:57+08:00
draft: false
toc: TRUE
categories:
  - 网络
  - 面试题
tags:
  - 网络
  - 面试题
---

{{< spoiler >}} 

{{< / spoiler >}}



# 网络分层



## 网络模型分为哪几类

{{< spoiler >}} 

1. OSI七层模型 ： 物理层、链路层、网络层、传输层、会话层、表示层、应用层
2. TCP/IP四层模型 ： 接口层、网际层、传输层、应用层
3. 五层模型 ： 物理层、链路层、网络层、传输层、应用层

{{< / spoiler >}}

## 概述OSI七层模型各层的作用及各层常见协议

{{< spoiler >}} 

自下而上依次为 : 物理层、链路层、网络层、传输层、会话层、表示层、应用层

{{< / spoiler >}}

| 分层   | 作用                                                         | 协议                                         | 设备           | 关键字                  |
| ------ | ------------------------------------------------------------ | -------------------------------------------- | -------------- | ----------------------- |
| 应用层 | 负责顶层协议，例如数据封装、分配IP、DNS解析                  | HTTP、FTP、Telnet、DNS                       | 浏览器、APP    |                         |
| 表示层 | 转换、压缩、加密数据                                         | ASCII、PNG、JPEG                             | 浏览器、APP    |                         |
| 会话层 | 负责两个应用进程之间的逻辑连接                               | SSL、TLS、、SQL、RPC                         | 浏览器、APP    |                         |
| 传输层 | 传输数据，确保数据包按顺序接收且没有被破坏                   | TCP、UDP                                     | 计算机         | 流量控制、拥塞控制      |
| 网络层 | 为网络上的不同主机提供通信                                   | IPv4、IPv6、ARP、ICMP                        |                |                         |
| 链路层 | 采用差错检测、差错控制等方法，以帧为单位向网络层提供高质量的数据传输服务 | 点对点协议PPP、广播协议                      | 交换机、路由器 | MAC、MTU、CRC、滑动窗口 |
| 物理层 | 利用传输介质为相邻的计算机节点完成比特流的透明传送           | IEEE802.X、Bluetooth、WI-FI协议、USB接口协议 | 网卡、网线     | 全双工通信、信道复用    |



# 三次握手和四次挥手

这里先放一张TCP状态变迁图

![img](https://gitee.com/1162492411/pic/raw/master/网络-TCP状态变迁.png)

## 简述HTTP三次握手的流程

![TCP三次握手](https://gitee.com/1162492411/pic/raw/master/三次握手.png)

![三次握手](https://gitee.com/1162492411/pic/raw/master/三次握手-详细版.png)

## 为什么需要三次握手

{{< spoiler >}} 

三次握手的目的是建立可靠的通信信道，说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。简单来说，基本思想就是**“让我知道你已经知道”**了

第一次握手：Client 什么都不能确认；Server 确认了对方发送正常，自己接收正常

第二次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：对方发送正常，自己接收正常

第三次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送、接收正常

所以三次握手就能确认双发收发功能都正常，缺一不可。

{{< / spoiler >}}

## 第二次握手为什么回传SYN

{{< spoiler >}} 

SYN用于建立并确认从服务端到客户端的通信。

{{< / spoiler >}}

## 什么是半连接队列

{{< spoiler >}} 

服务器第一次收到客户端的 SYN 之后，就会处于 SYN_RCVD 状态，此时双方还没有完全建立其连接，服务器会把此种状态下请求连接放在一个**队列**里，我们把这种队列称之为**半连接队列**

{{< / spoiler >}}

## 什么是全连接队列

{{< spoiler >}} 

已经完成三次握手，建立起连接的就会放在全连接队列中。如果队列满了就有可能会出现丢包现象

{{< / spoiler >}}

## 三次握手过程中可以携带数据吗

{{< spoiler >}} 

**第一次、第二次握手不可以携带数据**，但是第三次可以。

{{< / spoiler >}}

## 什么是SYN攻击，如何防范

{{< spoiler >}} 

SYN攻击就是Client在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包，Server则回复确认包，并等待Client确认，由于源地址不存在，因此Server需要不断重发直至超时，这些伪造的SYN包将长时间占用未连接队列，导致正常的SYN请求因为队列满而被丢弃，从而引起网络拥塞甚至系统瘫痪

常见的防御 SYN 攻击的方法有如下几种：

- 缩短超时（SYN Timeout）时间

- 增加最大半连接数

- 过滤网关防护

- SYN cookies技术

  {{< / spoiler >}}

## 简述四次挥手的流程

![四次挥手](https://gitee.com/1162492411/pic/raw/master/四次挥手-详细版.png)

## 四次挥手时为什么客户端最后还要等待2MSL

{{< spoiler >}} 

第一，保证客户端发送的最后一个ACK报文能够到达服务器，因为这个ACK报文可能丢失，站在服务器的角度看来，我已经发送了FIN+ACK报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次，而客户端就能在这个2MSL时间段内收到这个重传的报文，接着给出回应报文，并且会重启2MSL计时器。

第二，防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文

{{< / spoiler >}}

## 为什么建立连接是三次握手，关闭连接确是四次挥手呢

{{< spoiler >}} 

简单来说，建立连接时服务器端的ACK/SYN一次性发送给客户端，但关闭连接时ACK/FIN一般分为两次发送给客户端(目的是使得服务端传送完毕数据)。详细来说,

* 建立连接的时候， 服务器在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。

* 关闭连接时，服务器收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送，从而导致多了一次。

  {{< / spoiler >}}

## 如果已经建立了连接，但是客户端突然出现故障了怎么办

{{< spoiler >}} 

与UDP相比，TCP还设有一个保活计时器，服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。相对应的配置项为net.ipv4.tcp_keepalive_time、net.ipv4.tcp_keepalive_intvl、net.ipv4.tcp_keepalive_probes。

{{< / spoiler >}}

# TCP/UDP

## TCP和UDP的区别

![TCP、UDP协议的区别](https://gitee.com/1162492411/pic/raw/master/tcp-vs-udp.jpg)

## TCP如何保证可靠传输

{{< spoiler >}} 

* 分块 ：应用数据被分割成 TCP 认为最适合发送的数据块。

* 编号 ：TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。

* 校验和 ： TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。

* 去重 ：TCP 的接收端会丢弃重复的数据。

* 流量控制 ： TCP 连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 （TCP 利用滑动窗口实现流量控制）

* 拥塞控制 ：当网络拥塞时，减少数据的发送。

* ARQ协议 ：也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。

* 超时重传 ：当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段

  {{< / spoiler >}}

# HTTP/HTTPS

## HTTP1.0与HTTP1.1有什么区别

{{< spoiler >}} 

* 长连接 ： 1.0默认短连接，1.1默认长连接，并且1.1支持流水线，可以多个HTTP连接共用同一个TCP连接

* 缓存机制 ：1.0使用header中的If-Modified-Since,Expires控制缓存，1.1更加丰富，如Entity tag，If-Unmodified-Since, If-Match, If-None-Match

* 带宽优化 ：1.1支持通过header中指定range来获取资源的某个部分

* 错误码 ：1.1相比1.0增加了24个错误码

* Host处理 ：1.0并没有host，而1.1强制必须存在host

  {{< / spoiler >}}

## HTTP1.1和HTTP2.0有什么区别

{{< spoiler >}} 

* 本质区别 ：1.1基于文本分割, 2.0基于二进制

* 多路复用 ：2.0支持在同一个TCP中存在多个流，也就是可以发送多个请求，对端可以通过帧中的标识知道属于哪个请求

* header压缩 ：1.1每次都需要发送header，2.0将header压缩，同时通信的两端各自维护了header键名索引

* 服务端推送 ：2.0可以在服务端主动推送数据到客户端

* 流量控制 ：2.0中的通信双方可以在请求时声明需要的数据字节大小

  {{< / spoiler >}}

## QUIC相对HTTP2有什么区别

{{< spoiler >}} 

* 传输层协议 ：QUIC基于UDP，HTTP2基于TCP

* 连接建立时间 ：QUIC可以实现0-RTT建立连接，而TCP与SSL/TLS(1.0,1.1,1.2)每次建连需要TCP三次握手+安全握手，需要4~5个RRT

* 拥塞控制 ：多个数据在TCP连接上传输时，若一个数据包出现问题，TCP需要等待该包重传后，才能继续传输其它数据包。但在QUIC中，因为其基于UDP协议，UDP数据包在出问题需要重传时，并不会对其他数据包传输产生影响

* 重传机制 ：QUIC协议的每个数据包除了本身的数据以外，会带有其他数据包的部分数据，在少量丢包的情况下，可以使用其他数据包的冗余数据完成数据组装而无需重传

* 重启会话 ：TCP是基于两端的ip和端口和协议来建立连接，而QUIC基于特有的Connection ID 来建立连接

* 头部加密 ：TCP 协议头部未经过加密和认证，但 QUIC 所有的头部信息均经过认证，并且对所有信息进行加密，可有效避免数据传输过程中被中间设备截取并篡改

  {{< / spoiler >}}

## HTTP和HTTPS的区别

{{< spoiler >}} 

* 端口 ：http默认80端口，https默认443端口

* 安全性 ：http明文传输，https加密传输，安全性高

* 连接建立时间与响应时间 ：http无需加密，只需要三次握手，建立连接时间短，https需要先三次握手再ssl握手，建立连接时间长

* 消耗资源 ：https需要额外加解密，相比http更加消耗资源

  {{< / spoiler >}}

## SSL和TLS什么关系

{{< spoiler >}} 

TLS是SSL标准化的产物。早期SSL分为1.0、2.0、3.0版本，SSL3.0 = TLS1.0，TLS后续又产生了1.1、1.2版本等

{{< / spoiler >}}

## 概述ssl握手流程

{{< spoiler >}} 

1.客户端通知加密算法,双方根据加密算法来交换加密所需的证书、随机数、配置参数等信息

2.根据上一步的加密算法及相关参数计算出预主密钥

3.根据预主密钥生成主密钥

4.双方互相发送握手完成信息，后续根据主密钥来加密通信数据

{{< / spoiler >}}

## 给出基于RSA的SSL握手流程和基于DH的SSL握手流程

RSA的SSL握手流程

![RSA-SSL握手流程](https://gitee.com/1162492411/pic/raw/master/网络-ssl握手-rsa.png)

DH的SSL握手流程

![img](https://gitee.com/1162492411/pic/raw/master/网络-dh.png)

## 概述给予RSA和DH算法的SSL握手流程的区别

{{< spoiler >}} 

区别就在于密钥交换与身份认证

* RSA非对称算法，利用客户端利用公钥加密预主密钥发送给服务端完成密钥交换，服务端利用私钥解密完成身份认证
* DH对称算法，利用各自发送DH参数完成密钥交换，服务器私钥签名数据，客户端公钥验签完成身份认证

{{< / spoiler >}}

## SSL握手阶段连接意外中断后的恢复方法有哪些，并比较它们的优缺点

{{< spoiler >}} 

* session id
  * 流程 ：当 Client 通过一次完整的握手，与 Server 建立了一次完整的 Session，Server 会记录这次 Session 的信息，以备恢复会话的时候使用，其中就包含session id
  * 优点 ：将握手耗时从2-RTT减少为1-RTT；减少双方的负载，不需要再次消耗CPU计算
  * 缺点 ：session id仅存在于单机中
* session ticket
  * 流程 ：服务器取出它的所有会话数据（状态）并进行加密 (密钥只有服务器知道)，再以票证的方式发回客户端；客户端恢复会话时在 ClientHello 的扩展字段 session_ticket 中携带加密信息将票证提交回服务器，由服务器检查票证的完整性，解密其内容，再使用其中的信息恢复会话
  * 优点 ：可用于多台机器
  * 缺点 ：存储ticket需要消耗内存

{{< / spoiler >}}

## TLS1.3 相比TLS1.2有什么区别

{{< spoiler >}} 

* 密钥协商机制 ：引入新的密钥协商机制PSK
* 连接建立时间 ：支持 0-RTT 数据传输，在建立连接时节省了往返时间
* 加密算法 ：废弃了 3DES、RC4、AES-CBC 等加密组件，废弃了 SHA1、MD5 等哈希算法
* 安全性 ：ServerHello 之后的所有握手消息采取了加密操作，可见明文大大减少

{{< / spoiler >}}

## 概述QUIC的握手流程

![img](https://gitee.com/1162492411/pic/raw/master/QUIC-握手流程.png)



