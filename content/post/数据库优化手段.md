---
title: "数据库优化手段"
date: 2021-02-25T20:04:09+08:00
draft: true
categories:
  - 数据库
  - 优化
tags:
  - MySQL
  - Oracle
  - 优化
---

# 索引优化
## 索引创建的情形

* 经常出现在where或者order by中的字段
* 多表连接查询的关联字段或者外键涉及的字段
* group by的字段

## 索引的优化原则

* 对区分度比较大的字段创建索引，即不怎么重复的，如果是重复性比较高的字段，例如性别，只有男和女，给这样的字段加索引，效果不大
* 最左前缀
* 索引列上不要做任何操作(计算、函数、类型转换)，会导致索引失效
* 尽量使用覆盖索引：即要查询的列是索引列，这样可以不用回表
* 可以使用索引来避免排序，可以将排序字段也加入到索引中，group by同理
* like以通配符开头也会使得索引失效，所以最好通配符放在右边
* or连接的字段，只要有一个没有索引，那么就不会走索引
* 索引应该建在选择性高的字段上
* 索引应该建在小字段上，对于大的文本字段甚至超长字段，不要建索引，如果确需建立索引，根据业务可以考虑前缀索引
* 复合索引的建立需要进行仔细分析，尽量考虑用单字段索引代替
* 频繁进行数据操作的表，不要建立太多的索引

# 配置优化

* innodb_buffer_pool_size : 缓冲池大小,在专门用作MySQL数据库的服务器上，可以设置物理内存的50%~70%，典型值5-6GB(8GB内存)、20-25GB(32GB内存)、100-120GB(128GB内存)
* innodb_log_file_size : redo日志大小,可以调整为约1h左右产生的大小
* max_connections : 最大连接数
* innodb_file_per_table : 将表数据和索引放在共享表空间或者单独文件,off放在共享表空间,on放在单独的idb文件以便可以回收磁盘空间
* innodb_flush_log_at_trx_commit : 提交事务时是否立即刷新日志到硬盘，默认1实时写实时刷，0延迟写，2实时写延迟刷
* innodb_flush_method : 数据和日志写入硬盘的方式,默认fdatasync调用fsync()去刷数据文件与redo log的buffer，O_DSYNC使用O_SYNC方式打开和刷写redo log,使用fsync()刷写数据文件，O_DIRECT使用O_DIRECT打开数据文件，使用fsync()刷写数据文件跟redo log
* innodb_log_buffer_size : 设置缓存还未提交的事务的缓冲区的大小。一般默认值16MB是够用的，但如果事务之中含有blog/text等大字段，这个缓冲区会被很快填满会引起额外的IO负载。可通过查看innodb_log_waits状态，如果不为0的话，则需要增加innodb_log_buffer_size
* query_cache_size : 查询缓存的大小



# 查询SQL优化

1. 尽量减少扫描范围

2. 尽量避免在 WHERE 子句中对字段进行 NULL 值判断

3. 尽量避免在 WHERE 子句中使用 != 或 <> 操作符以免无法使用索引

4. 尽量避免在 WHERE 子句中使用 OR 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描(准确来讲应该是避免or连接时加入其他非索引列)

5. IN 和 NOT IN 的优化 : 对于连续的数值，能用 BETWEEN 就不要用 IN(个人猜测是早期数据库优化器问题，未实践)

6. like索引 ： select id from t where name like‘%abc%’ 或者select id from t where name like‘%abc’将无法使用索引

7. 尽量避免在 WHERE 子句中对字段进行表达式操作，应尽量避免在 WHERE 子句中对字段进行函数操作

8. 避免参数的隐式转换，例如单表查询时，索引列为字符串但SQL参数传入数字，或者两表关联查询时on条件中的列类型或者长度不一致

9. 尽量避免向客户端返回大数据量

10. 将需要查询的结果预先计算好放在表中，查询的时候再Select

11. 在IN后面值的列表中，将出现最频繁的值放在最前面，出现得最少的放在最后面，减少判断的次数(本质上还是减少数据规模)

12. 索引的使用规范：

    索引的创建要与应用结合考虑，建议大的 OLTP 表不要超过 6 个索引；

    尽可能的使用索引字段作为查询条件，尤其是聚簇索引，必要时可以通过 index index_name 来强制指定索引；

    避免对大表查询时进行 table scan，必要时考虑新建索引；

    在使用索引字段作为条件时，如果该索引是联合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，否则该索引将不会被使用

13. 当有一批处理的插入或更新时，用批量插入或批量更新，绝不会一条条记录的去更新

14. 